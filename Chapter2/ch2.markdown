# 第2章 重载运算符、类模板和抽象

数据结构常常由类生成，而且数据结构中经常使用结构来存储信息记录。另外，***结构中或者就在结构的下面，经常还有一些特殊的函数，这些函数称为重载运算符（ overloaded operator）函数***。
## 2.1 重载运算符
首先，我们回想运算符的概念。在过去所编写的程序中，运算符通常指的是些符号，作用于一个或者多个变量或常量，产生一个结果。符号+、<=、！和&&都是运算符的例子。有时候结果是经计算得出的值。有时候结果是true或者 false，就像i语句条件中的结果一样。运算符总能够获得某些类型的结果，否则就没有理由使用运算符了。但是，现在大家不得不改变思考运算符的方式。现在您（通常）应该将运算符看作是一些符号，作用于一个或者多个变量、常量或者对象，生成一个结果。

对于表达式

z = x + y;

来说，***如果+是一个重载运算符，那么这个表达式可以调用一个函数***。重复这一概念10次，让它深深植入您的脑海中，因为我确信大家还不习惯于这种想法。这就对了：这一表达式，看上去那么简单，但是可以调用程序员编写的函数。

对于if语句头

    if( x>y)

来说，如果符号>是一个重载运算符，那么这个表达式也可以调用一个函数。再次强调，如果您还不习惯这种想法，请不停地重复这一想法，直到您习惯了这一想法再继续向下阅读。此时，您还不必理解if语句头是如何调用函数的，或者if语句的分支是什么；这里，您只需意识到它可以调用一个函数即可。

在函数中，我们必须考虑传递进来的参数和返回的结果。从过去的经验我们知道函数的返回值将取代函数调用。例如，如果函数foo返回一个整型数3，那么表达式

    x = foo() + 2;

将把值5存放到x中。这是因为foo()被其返回值3取代，然后将3加上2得到5，最后将5存储在x中。

在重载运算符函数中，返回值也取代函数调用。此时，大家可能还不十分了解函数调用指的是什么。在重载运算符函数中，函数调用包括运算符和运算符所作用的变量、常量或对象。因此，在表达式

    z = x + y;

中，+是重载运算符，表达式x+y是函数调用整个表达式x+y将被这个函数的返回值取代。然后把这个返回值赋给z。同理，在表达式

    if( x>y)

中，>是重载运算符，表达式x>y是函数调用。因此整个表达式x>y将被这个函数的返回值取代。在这种情况下，该函数的返回值可能是一个布尔类型，因此整个表达式x>y将被函数执行完后所返回的true或者false取代。

在这些例子中，如果ⅹ和y都不是对象，我们就无法使用重载运算符函数。例如，如果它们都是整型，那么C++就知道如何去做了；C++就会像往常一样将它们加在一起。如果它们中的一个或者两个都是对象，那么我们就可以为它们编写一个重载运算符函数。实际上，我们必须这样做，否则编译器会报错；如果它们都是对象，那么C++就完全不知道如何处理运算。因此，***重载运算符函数只能为对象编写，而且必须为作用于对象的运算符编写重载运算符函数***。

下面我们以前面介绍的 CarType结构为例做进一步解释
```C++
struct CarType {
    string maker;
    int year;
    float price;
};
```
假定我们将 myCar声明为该结构的一个对象，并且为该对象的所有数据成员赋值。然后我们编写下述代码：
```C++
if(myCar >2000)
    cout < "My car is more than 2000!"<< endl;
```
C++不知道如何处理这段代码。C++不知道是将myCar中的year与2000比较，还是将myCar中的price与200较我们必须通过编写一个C++能够执行的函数，告诉C++如何处理这一情况。如果函数执行后返回true，那么函数将把表达式myCar>200替换为true。然后，因为条件为真，所以上述代码将输出所示范的文本。无论何时，当在对象上使用运算符时，如果不为运算符编写一个重载运算符函数，编译器将会报错。

但是，如何才能编写一个重载运算符函数呢?因为运算符的广泛性，所以有许多种方式进行编写。我们将讨论限定于二元运算符 binary operator）而且是只用于计算或者比较的运算符。**二元运算符作用于2个变量、常量或者对象**。后面我们之为**操作数(operand)**。因此，简言之，一个二元运算符只作用于2个操作数。C++中还有可重载的只作用于一个对象的一元运算符，例如++运算符。另外还有不是用于计算或者比较的二元运算符，例如cout通常使用的运算符<<。但是，在数据结构中并不经常使用这些类型的运算符。为了重载运算符，大家最好查阅关于面向对象编程的C++教材。（Java中没有重载运算符的概念）。

在C++中，二元运算符通常左边有一个操作数，右边有一个操作数。（在其他计算机语言中，可能情形并不总是如此；两个操作数可能都位于运算符的左边，也有可能都位于运算符的右边）。前面讲过，为了编写重载运算符函数，两个操作数必须有一个是对象。如果左边的操作数是结构的对象，那么整个函数定义通常位于结构定义内部。然后运算符右边的作数作为参数传递给函数。下面是一个描述这样个函数的简单程序：


首先，我们先分析第12行。这一行代码是重载运算符的函数定义。将这样的函数定义放在结构中是可行的，因为结构定义通常没有关联的结构实现文件。注意第12行的函数定义拥有一个布尔类型的返回类型，这也是我们所期望的。这里函数